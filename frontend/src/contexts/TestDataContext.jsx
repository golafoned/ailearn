import {
    createContext,
    useContext,
    useState,
    useCallback,
    useMemo,
} from "react";
import { apiFetch, ApiError, mapErrorCode } from "../utils/apiClient";
import { useToast } from "./ToastContext";
import { useRef } from "react";

const TestDataContext = createContext(null);

export function TestDataProvider({ children }) {
    const toast = useToast();
    const lastToastRef = useRef({ code: null, message: null });
    // Tests generated by the current user (no listing endpoint yet) -> placeholder empty array
    const [tests, setTests] = useState([]);
    const [testsPageInfo, setTestsPageInfo] = useState({
        page: 1,
        pageSize: 20,
        total: 0,
        totalPages: 0,
    });
    const [previewTest, setPreviewTest] = useState(null); // generated test after polling (metadata + questions)
    const [lastGeneratedCode, setLastGeneratedCode] = useState(null);
    const [currentTest, setCurrentTest] = useState(null); // test fetched by code for landing/attempt
    const [attempt, setAttempt] = useState(null); // current active attempt {attemptId, code, startedAt}
    const [attemptsForTest, setAttemptsForTest] = useState([]); // owner view list
    const [myAttempts, setMyAttempts] = useState([]); // authenticated user's attempts
    const [attemptDetail, setAttemptDetail] = useState(null); // participant view of own attempt detail
    const [ownerAttemptDetail, setOwnerAttemptDetail] = useState(null); // owner view of specific participant attempt
    const [leaderboard, setLeaderboard] = useState([]); // leaderboard entries
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const [errorCode, setErrorCode] = useState(null);

    const clearError = () => setError(null);

    // Fetch test metadata + question shells by share code
    const fetchTestByCode = useCallback(
        async (code) => {
            if (!code) return null;
            setLoading(true);
            setError(null);
            try {
                const data = await apiFetch(`/api/v1/tests/code/${code}`);
                setCurrentTest(data);
                setErrorCode(null);
                return data;
            } catch (e) {
                if (e instanceof ApiError) {
                    const friendly = mapErrorCode(e.code, e.message);
                    setErrorCode(e.code || null);
                    setError(friendly);
                    if (
                        (!lastToastRef.current.code &&
                            !lastToastRef.current.message) ||
                        lastToastRef.current.code !== e.code ||
                        lastToastRef.current.message !== friendly
                    ) {
                        toast.error(friendly);
                        lastToastRef.current.code = e.code;
                        lastToastRef.current.message = friendly;
                    }
                } else {
                    setError("Failed to load test");
                    toast.error("Failed to load test");
                }
                throw e;
            } finally {
                setLoading(false);
            }
        },
        [toast]
    );

    // Start attempt (public)
    const startAttempt = useCallback(
        async ({ code, participantName, displayName }) => {
            setLoading(true);
            setError(null);
            try {
                const resp = await apiFetch("/api/v1/tests/start", {
                    method: "POST",
                    body: { code, participantName, displayName },
                });
                setAttempt(resp);
                return resp;
            } catch (e) {
                if (e instanceof ApiError) {
                    const friendly = mapErrorCode(e.code, e.message);
                    setErrorCode(e.code || null);
                    setError(friendly);
                    if (
                        lastToastRef.current.message !== friendly ||
                        lastToastRef.current.code !== e.code
                    ) {
                        toast.error(friendly);
                        lastToastRef.current.code = e.code;
                        lastToastRef.current.message = friendly;
                    }
                } else {
                    setError("Failed to start attempt");
                    toast.error("Failed to start attempt");
                }
                throw e;
            } finally {
                setLoading(false);
            }
        },
        [toast]
    );

    // Submit attempt answers
    const submitAttempt = useCallback(
        async ({ attemptId, answers }) => {
            setLoading(true);
            setError(null);
            try {
                const resp = await apiFetch("/api/v1/tests/submit", {
                    method: "POST",
                    body: { attemptId, answers },
                });
                // Merge into attempt state
                setAttempt((a) => (a ? { ...a, ...resp } : a));
                return resp;
            } catch (e) {
                if (e instanceof ApiError) {
                    const friendly = mapErrorCode(e.code, e.message);
                    setErrorCode(e.code || null);
                    setError(friendly);
                    if (
                        lastToastRef.current.message !== friendly ||
                        lastToastRef.current.code !== e.code
                    ) {
                        toast.error(friendly);
                        lastToastRef.current.code = e.code;
                        lastToastRef.current.message = friendly;
                    }
                } else {
                    setError("Failed to submit attempt");
                    toast.error("Failed to submit attempt");
                }
                throw e;
            } finally {
                setLoading(false);
            }
        },
        [toast]
    );

    // Participant fetch own attempt detail (after submission)
    const fetchAttemptDetail = useCallback(async (attemptId) => {
        if (!attemptId) return null;
        setLoading(true);
        setError(null);
        try {
            const resp = await apiFetch(`/api/v1/tests/attempt/${attemptId}`);
            setAttemptDetail(resp);
            return resp;
        } catch (e) {
            if (e instanceof ApiError) {
                setErrorCode(e.code || null);
                setError(mapErrorCode(e.code, e.message));
            } else setError("Failed to load attempt detail");
            throw e;
        } finally {
            setLoading(false);
        }
    }, []);

    // Owner fetch specific attempt detail
    const fetchOwnerAttemptDetail = useCallback(
        async ({ testId, attemptId }) => {
            if (!testId || !attemptId) return null;
            setLoading(true);
            setError(null);
            try {
                const resp = await apiFetch(
                    `/api/v1/tests/${testId}/attempts/${attemptId}`
                );
                setOwnerAttemptDetail(resp);
                return resp;
            } catch (e) {
                if (e instanceof ApiError) {
                    setErrorCode(e.code || null);
                    setError(mapErrorCode(e.code, e.message));
                } else setError("Failed to load attempt detail");
                throw e;
            } finally {
                setLoading(false);
            }
        },
        []
    );

    // Leaderboard fetch
    const fetchLeaderboard = useCallback(async (testId) => {
        if (!testId) return [];
        setLoading(true);
        setError(null);
        try {
            const resp = await apiFetch(`/api/v1/tests/${testId}/leaderboard`);
            setLeaderboard(resp.entries || resp || []);
            return resp.entries || resp || [];
        } catch (e) {
            if (e instanceof ApiError) {
                setErrorCode(e.code || null);
                setError(mapErrorCode(e.code, e.message));
            } else setError("Failed to load leaderboard");
            throw e;
        } finally {
            setLoading(false);
        }
    }, []);

    // Close test (owner)
    const closeTest = useCallback(async (testId) => {
        if (!testId) return null;
        setLoading(true);
        setError(null);
        try {
            const resp = await apiFetch(`/api/v1/tests/${testId}/close`, {
                method: "POST",
            });
            // Update tests list local state if present
            setTests((prev) =>
                prev.map((t) =>
                    t.id === testId ? { ...t, closedAt: resp.closedAt } : t
                )
            );
            return resp;
        } catch (e) {
            if (e instanceof ApiError) {
                setErrorCode(e.code || null);
                setError(mapErrorCode(e.code, e.message));
            } else setError("Failed to close test");
            throw e;
        } finally {
            setLoading(false);
        }
    }, []);

    // List attempts for a test (owner)
    const fetchAttemptsForTest = useCallback(async (testId) => {
        if (!testId) return [];
        setLoading(true);
        setError(null);
        try {
            const resp = await apiFetch(`/api/v1/tests/${testId}/attempts`);
            setAttemptsForTest(resp.attempts || []);
            return resp.attempts || [];
        } catch (e) {
            if (e instanceof ApiError) {
                setErrorCode(e.code || null);
                setError(mapErrorCode(e.code, e.message));
            } else setError("Failed to load attempts");
            throw e;
        } finally {
            setLoading(false);
        }
    }, []);

    // List my attempts (auth)
    const fetchMyAttempts = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const resp = await apiFetch("/api/v1/tests/me/attempts");
            setMyAttempts(resp.attempts || []);
            return resp.attempts || [];
        } catch (e) {
            if (e instanceof ApiError) {
                setErrorCode(e.code || null);
                setError(mapErrorCode(e.code, e.message));
            } else setError("Failed to load my attempts");
            throw e;
        } finally {
            setLoading(false);
        }
    }, []);

    const addLocalGeneratedTest = useCallback((t) => {
        setTests((prev) => [t, ...prev]);
    }, []);

    const fetchMyTests = useCallback(
        async ({ page = 1, pageSize = 20, append = false } = {}) => {
            setLoading(true);
            setError(null);
            try {
                const data = await apiFetch(
                    `/api/v1/tests/mine?page=${page}&pageSize=${pageSize}`
                );
                setTests((prev) =>
                    append ? [...prev, ...data.items] : data.items
                );
                setTestsPageInfo({
                    page: data.page,
                    pageSize: data.pageSize,
                    total: data.total,
                    totalPages: data.totalPages,
                });
                return data;
            } catch (e) {
                if (e instanceof ApiError) {
                    setErrorCode(e.code || null);
                    setError(mapErrorCode(e.code, e.message));
                } else setError("Failed to load tests");
                throw e;
            } finally {
                setLoading(false);
            }
        },
        []
    );

    const getTestById = useCallback(
        (id) => tests.find((t) => t.id === id) || null,
        [tests]
    );

    const value = useMemo(
        () => ({
            // State
            tests,
            previewTest,
            lastGeneratedCode,
            currentTest,
            attempt,
            attemptsForTest,
            myAttempts,
            attemptDetail,
            ownerAttemptDetail,
            leaderboard,
            loading,
            error,
            errorCode,
            // Setters / actions
            setPreviewTest,
            setLastGeneratedCode,
            addLocalGeneratedTest,
            fetchMyTests,
            testsPageInfo,
            fetchTestByCode,
            startAttempt,
            submitAttempt,
            fetchAttemptsForTest,
            fetchMyAttempts,
            fetchAttemptDetail,
            fetchOwnerAttemptDetail,
            fetchLeaderboard,
            closeTest,
            clearError,
            setAttempt,
            setCurrentTest,
            getTestById,
            setAttemptDetail,
            setOwnerAttemptDetail,
            setLeaderboard,
            setErrorCode,
        }),
        [
            tests,
            previewTest,
            lastGeneratedCode,
            currentTest,
            attempt,
            attemptsForTest,
            myAttempts,
            attemptDetail,
            ownerAttemptDetail,
            leaderboard,
            loading,
            error,
            errorCode,
            fetchTestByCode,
            startAttempt,
            submitAttempt,
            fetchAttemptsForTest,
            fetchMyAttempts,
            fetchAttemptDetail,
            fetchOwnerAttemptDetail,
            fetchLeaderboard,
            closeTest,
            addLocalGeneratedTest,
            fetchMyTests,
            testsPageInfo,
            getTestById,
        ]
    );

    return (
        <TestDataContext.Provider value={value}>
            {children}
        </TestDataContext.Provider>
    );
}

// eslint-disable-next-line react-refresh/only-export-components
export const useTestData = () => {
    const ctx = useContext(TestDataContext);
    if (!ctx)
        throw new Error("useTestData must be used within TestDataProvider");
    return ctx;
};
